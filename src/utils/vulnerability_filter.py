"""
Vulnerability Filter for IHACPA v2.0

Filters out false positive vulnerabilities that are not related to Python packages.
Implements smart filtering based on CVE descriptions and package context.
"""

import re
from typing import Dict, List, Tuple, Optional
import logging


class VulnerabilityFilter:
    """Smart filter for removing false positive vulnerabilities"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Known package name conflicts (Python package -> Other software)
        self.package_conflicts = {
            'arrow': {
                'false_positive_indicators': ['apache arrow', 'arrow c++', 'apache', 'parquet'],
                'description': 'Apache Arrow C++ library'
            },
            'babel': {
                'false_positive_indicators': ['babel.js', 'javascript', 'transpiler', 'ecmascript', 'node.js', 'npm'],
                'description': 'Babel JavaScript compiler'
            },
            'constantly': {
                'false_positive_indicators': ['linux', 'kernel', 'ubuntu', 'debian'],
                'description': 'Linux/system packages'
            },
            'coverage': {
                'false_positive_indicators': ['code coverage', 'java', '.net', 'javascript'],
                'description': 'Non-Python coverage tools'
            },
            'decorator': {
                'false_positive_indicators': ['design pattern', 'java', 'javascript', 'typescript'],
                'description': 'Non-Python decorator implementations'
            },
            'distributed': {
                'false_positive_indicators': ['distributed systems', 'hadoop', 'spark', 'kubernetes'],
                'description': 'Distributed computing platforms'
            },
            'executing': {
                'false_positive_indicators': ['execution', 'shell', 'command', 'linux'],
                'description': 'System execution tools'
            },
            'graphviz': {
                'false_positive_indicators': ['graphviz software', 'dot', 'visualization tool', 'at&t'],
                'description': 'Graphviz visualization software (not Python wrapper)'
            },
            'hyperlink': {
                'false_positive_indicators': ['html', 'web', 'browser', 'url'],
                'description': 'Web/HTML hyperlink tools'
            },
            'imageio': {
                'false_positive_indicators': ['oracle', 'java', 'javax.imageio', 'jdk'],
                'description': 'Oracle Java ImageIO'
            },
            'incremental': {
                'false_positive_indicators': ['incremental backup', 'incremental update', 'system'],
                'description': 'System incremental tools'
            },
            'keyring': {
                'false_positive_indicators': ['gnome', 'kde', 'macos', 'windows', 'system keyring'],
                'description': 'System keyring services'
            },
            'lime': {
                'false_positive_indicators': ['linux memory', 'forensics', 'kernel'],
                'description': 'Linux Memory Extractor'
            },
            'lxml': {
                'false_positive_indicators': ['libxml2', 'libxslt', 'c library', 'xml parser'],
                'description': 'libxml2/libxslt C libraries'
            },
            'markdown': {
                'false_positive_indicators': ['markdown-it', 'javascript', 'node.js', 'commonmark'],
                'description': 'JavaScript markdown parsers'
            },
            'packaging': {
                'false_positive_indicators': ['rpm', 'deb', 'apt', 'yum', 'package manager'],
                'description': 'System package managers'
            },
            'panel': {
                'false_positive_indicators': ['control panel', 'admin panel', 'web panel'],
                'description': 'Web/admin panels'
            },
            'param': {
                'false_positive_indicators': ['parameter', 'command line', 'argument'],
                'description': 'Generic parameter tools'
            },
            'retrying': {
                'false_positive_indicators': ['retry logic', 'network retry', 'http retry'],
                'description': 'Generic retry mechanisms'
            },
            'shap': {
                'false_positive_indicators': ['shapley', 'game theory', 'economics'],
                'description': 'Non-ML SHAP implementations'
            },
            'sip': {
                'false_positive_indicators': ['session initiation protocol', 'voip', 'telephony'],
                'description': 'SIP telephony protocol'
            },
            'six': {
                'false_positive_indicators': ['six degrees', 'six sigma', 'version 6'],
                'description': 'Non-Python six references'
            },
            'tables': {
                'false_positive_indicators': ['database tables', 'html tables', 'table structure'],
                'description': 'Generic table references'
            },
            'watchdog': {
                'false_positive_indicators': ['system watchdog', 'hardware watchdog', 'linux watchdog'],
                'description': 'System watchdog timers'
            },
            'xarray': {
                'false_positive_indicators': ['array processing', 'numpy array', 'multidimensional'],
                'description': 'Generic array processing'
            }
        }
        
        # Generic non-Python indicators
        self.non_python_indicators = [
            'java', 'javascript', 'node.js', 'npm', 'ruby', 'perl', 'php',
            'c++', 'c library', 'golang', 'rust', '.net', 'c#',
            'android', 'ios', 'windows api', 'linux kernel',
            'apache', 'nginx', 'tomcat', 'jenkins'
        ]
        
        # Python-specific indicators
        self.python_indicators = [
            'python', 'pip', 'pypi', 'setuptools', 'django', 'flask',
            'numpy', 'pandas', 'scikit', 'jupyter', 'ipython'
        ]
    
    def is_python_related_cve(self, cve_id: str, cve_description: str, 
                             package_name: str, affected_products: Optional[str] = None) -> Tuple[bool, float, str]:
        """
        Determine if a CVE is related to the Python package.
        
        Returns:
            Tuple of (is_relevant, confidence, reason)
            - is_relevant: True if CVE is likely for the Python package
            - confidence: 0.0 to 1.0 confidence score
            - reason: Explanation for the decision
        """
        cve_desc_lower = cve_description.lower() if cve_description else ''
        affected_lower = affected_products.lower() if affected_products else ''
        combined_text = f"{cve_desc_lower} {affected_lower}"
        
        # Check if this is a known conflicting package name
        if package_name.lower() in self.package_conflicts:
            conflict = self.package_conflicts[package_name.lower()]
            
            # Check for false positive indicators
            for indicator in conflict['false_positive_indicators']:
                if indicator in combined_text:
                    return False, 0.9, f"CVE likely for {conflict['description']}, not Python package"
            
            # If package name appears with Python indicators, it's likely valid
            if any(f"python {package_name.lower()}" in combined_text or 
                   f"{package_name.lower()} python" in combined_text or
                   f"py{package_name.lower()}" in combined_text for _ in [1]):
                return True, 0.8, "CVE mentions Python explicitly with package name"
        
        # Check for explicit Python mentions
        python_score = sum(1 for indicator in self.python_indicators if indicator in combined_text)
        non_python_score = sum(1 for indicator in self.non_python_indicators if indicator in combined_text)
        
        # Strong Python indication
        if python_score > 0 and non_python_score == 0:
            return True, min(0.9, 0.6 + python_score * 0.1), "CVE contains Python-specific references"
        
        # Strong non-Python indication
        if non_python_score > 0 and python_score == 0:
            return False, min(0.9, 0.6 + non_python_score * 0.1), "CVE contains non-Python technology references"
        
        # Mixed signals - need manual review
        if python_score > 0 and non_python_score > 0:
            return True, 0.5, "CVE contains mixed technology references - manual review recommended"
        
        # No clear indicators - default to uncertain
        return True, 0.3, "No clear technology indicators - manual review recommended"
    
    def filter_vulnerabilities(self, vulnerabilities: List[Dict], package_name: str) -> List[Dict]:
        """
        Filter a list of vulnerabilities to remove likely false positives.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
            package_name: Name of the Python package
            
        Returns:
            Filtered list of vulnerabilities with metadata
        """
        filtered = []
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('cve_id', vuln.get('id', ''))
            description = vuln.get('description', '')
            affected_products = vuln.get('affected_products', '')
            
            is_relevant, confidence, reason = self.is_python_related_cve(
                cve_id, description, package_name, affected_products
            )
            
            # Add filtering metadata
            vuln['filter_metadata'] = {
                'is_python_related': is_relevant,
                'confidence': confidence,
                'filter_reason': reason,
                'requires_manual_review': confidence < 0.7
            }
            
            # Only include if relevant or uncertain (for manual review)
            if is_relevant or confidence < 0.5:
                filtered.append(vuln)
            else:
                self.logger.debug(
                    f"Filtered out {cve_id} for {package_name}: {reason} (confidence: {confidence})"
                )
        
        return filtered
    
    def get_package_health_indicators(self, package_info: Dict) -> Dict[str, any]:
        """
        Check package health indicators like maintenance status.
        
        Args:
            package_info: Package information from PyPI
            
        Returns:
            Dictionary with health indicators
        """
        health = {
            'is_maintained': True,
            'maintenance_warnings': [],
            'last_release_date': None,
            'days_since_last_release': None
        }
        
        # Check for specific packages known to be in maintenance mode
        package_name = package_info.get('name', '').lower()
        if package_name == 'py':
            health['is_maintained'] = False
            health['maintenance_warnings'].append(
                "Package 'py' is in maintenance mode since 2021 and should not be used for new code"
            )
        
        # Add more health checks here
        # - Last release date > 2 years
        # - No recent commits
        # - Deprecated classifiers
        
        return health