"""
Columns O & P: NIST NVD Processor

Column O: NIST NVD Lookup URL
Column P: NIST NVD Lookup Result

Integrates with our AI-based NVD sandbox for comprehensive vulnerability scanning.
Based on retired version's sophisticated NVD processing logic.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.nvd import NVDSandbox
from ....core.sandbox_manager import SandboxManager


class NISTNVDProcessor:
    """Processor for Columns O & P - NIST NVD Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for NVD scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column O: NIST NVD Lookup URL
        
        Generates the search URL for NIST NVD database.
        Based on retired version's URL generation logic.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with NVD URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column O (nist_nvd_url) for {package_name}")
            
            # Generate NVD search URL following retired version's pattern
            base_url = "https://nvd.nist.gov/vuln/search/results"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?form_type=Basic&results_type=overview&query={search_query}&search_type=all&isCpeNameSearch=false"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "NVD NIST"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'NIST NVD search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column O for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error generating NVD URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column P: NIST NVD Lookup Result
        
        Performs actual vulnerability scanning using our AI-based NVD sandbox.
        Based on retired version's sophisticated NVD analysis.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with NVD scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column P (nist_nvd_result) for {package_name} v{current_version}")
            
            # Get NVD sandbox from our AI infrastructure
            nvd_sandbox = await self.sandbox_manager.get_sandbox('nvd')
            if not nvd_sandbox:
                return {
                    'value': 'NVD scanner not available',
                    'color': 'not_available',
                    'font': 'not_available',
                    'note': 'NVD sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced NVD sandbox
            scan_result = await nvd_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'security_risk',
                    'font': 'security_risk',
                    'note': f'NVD scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's classification logic
            classification = self._classify_nvd_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column P for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error during NVD scan: {str(e)}'
            }
    
    def _classify_nvd_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify NVD scan results using retired version's sophisticated logic.
        
        Implements the 4-tier classification system from the old version:
        1. vulnerable - Confirmed security risks affecting current version
        2. safe - CVEs found but current version not affected  
        3. manual_review - Requires human assessment
        4. none_found - No relevant vulnerabilities
        """
        vuln_count = scan_result.total_vulnerabilities
        
        # Handle NEW packages (special case from old version)
        if current_version == "NEW":
            if vuln_count > 0:
                cve_list = [v.cve_id for v in scan_result.vulnerabilities[:15]]
                if vuln_count > 15:
                    cve_list.append(f"... and {vuln_count-15} more")
                summary = f"NEW package - Found {vuln_count} CVE records: {', '.join(cve_list)}"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'NEW package with {vuln_count} CVE records requires assessment',
                    'severity': 'UNKNOWN'
                }
            else:
                return {
                    'status': 'none_found',
                    'summary': 'NEW package - No CVE records found',
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': 'No NVD vulnerabilities found for NEW package',
                    'severity': 'NONE'
                }
        
        # No vulnerabilities found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No NVD vulnerabilities found',
                'severity': 'NONE'
            }
        
        # Analyze vulnerability relevance using sophisticated version checking
        affected_vulns = []
        version_check_indeterminate = False
        
        for vuln in scan_result.vulnerabilities:
            # Use sophisticated version impact checking from old version
            version_impact = self._check_version_impact_enhanced(vuln, current_version, package_name)
            
            if version_impact is None:
                # Indeterminate - can't determine version impact
                version_check_indeterminate = True
            elif version_impact:
                # Confirmed: current version is affected
                affected_vulns.append(vuln)
        
        # Apply retired version's sophisticated classification logic
        if affected_vulns:
            # Confirmed vulnerabilities affecting current version
            max_severity = self._get_highest_severity([v.severity_level.value for v in affected_vulns])
            summary = f"VULNERABLE - {len(affected_vulns)} CVEs affect v{current_version} (Highest: {max_severity})"
            return {
                'status': 'vulnerable',
                'summary': summary,
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'{len(affected_vulns)} NVD CVEs confirmed to affect current version',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # CVEs found but current version not affected (SAFE case from old version)
            if version_check_indeterminate:
                # Some CVEs couldn't be definitively checked
                summary = f"Manual review required - {vuln_count} CVEs need assessment"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'{vuln_count} NVD CVEs require manual version impact assessment',
                    'severity': 'UNKNOWN'
                }
            else:
                # All CVEs checked and current version is safe
                summary = f"SAFE - {vuln_count} CVEs found but v{current_version} not affected"
                return {
                    'status': 'safe',
                    'summary': summary,
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': f'{vuln_count} NVD CVEs found but current version not affected',
                    'severity': 'NONE'
                }
        else:
            # Fallback case - should not reach here but included for completeness
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} CVEs need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} NVD CVEs require manual assessment',
                'severity': 'UNKNOWN'
            }
    
    def _is_version_affected(self, vulnerability, current_version: str) -> bool:
        """
        Check if vulnerability affects the current version.
        
        Uses AI analysis and version range checking.
        """
        try:
            # Use vulnerability's affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_range(current_version, version_range):
                        return True
            
            # Fallback to confidence-based assessment
            if hasattr(vulnerability, 'confidence_level'):
                return vulnerability.confidence_level.value >= 0.7
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking version impact: {e}")
            return False
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version falls within vulnerability range."""
        try:
            from packaging import version as pkg_version
            
            # Simple range checking - could be enhanced
            if '<' in version_range:
                max_version = version_range.strip('<= ')
                return pkg_version.parse(version) < pkg_version.parse(max_version)
            elif '>' in version_range:
                min_version = version_range.strip('>= ')
                return pkg_version.parse(version) > pkg_version.parse(min_version)
            else:
                return version == version_range.strip()
                
        except Exception:
            return False
    
    def _check_version_impact_enhanced(self, vulnerability, current_version: str, package_name: str):
        """
        Enhanced version impact checking from retired version.
        
        Returns:
            True: Current version is affected
            False: Current version is not affected
            None: Cannot determine (indeterminate)
        """
        if not current_version or current_version == "NEW":
            return None
            
        try:
            from packaging import version
            current_ver = version.parse(current_version)
            
            # Check vulnerability's configuration data for version constraints
            # This mimics the old version's CPE and configuration parsing
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_enhanced_range(current_version, version_range):
                        return True
                return False
            
            # Fallback to confidence-based assessment (from AI analysis)
            if hasattr(vulnerability, 'confidence_level'):
                confidence = vulnerability.confidence_level.value if hasattr(vulnerability.confidence_level, 'value') else vulnerability.confidence_level
                # High confidence suggests the vulnerability is relevant to this version
                if confidence >= 0.8:
                    return True
                elif confidence <= 0.3:
                    return False
                else:
                    return None  # Indeterminate confidence
            
            # No definitive version information available
            return None
            
        except Exception as e:
            self.logger.warning(f"Error in enhanced version checking for {package_name}: {e}")
            return None
    
    def _version_in_enhanced_range(self, current_version: str, version_range: str) -> bool:
        """
        Enhanced version range checking from retired version.
        
        Supports complex version range formats like the old version.
        """
        try:
            from packaging import version
            current_ver = version.parse(current_version)
            
            # Handle complex range formats from old version
            if '<=' in version_range:
                max_version = version_range.strip('<= ')
                return current_ver <= version.parse(max_version)
            elif '<' in version_range:
                max_version = version_range.strip('< ')
                return current_ver < version.parse(max_version)
            elif '>=' in version_range:
                min_version = version_range.strip('>= ')
                return current_ver >= version.parse(min_version)
            elif '>' in version_range:
                min_version = version_range.strip('> ')
                return current_ver > version.parse(min_version)
            elif '==' in version_range:
                exact_version = version_range.strip('= ')
                return current_ver == version.parse(exact_version)
            elif ',' in version_range:
                # Handle range like ">=1.0.0,<2.0.0"
                parts = [p.strip() for p in version_range.split(',')]
                return all(self._version_in_enhanced_range(current_version, part) for part in parts)
            else:
                # Exact match
                return current_ver == version.parse(version_range.strip())
                
        except Exception as e:
            self.logger.debug(f"Error parsing version range '{version_range}': {e}")
            return False
    
    def _get_highest_severity(self, severities):
        """Get the highest severity from a list of severities (from old version)"""
        severity_priority = {
            'CRITICAL': 4,
            'HIGH': 3,
            'MEDIUM': 2,
            'LOW': 1,
            'NONE': 0,
            'UNKNOWN': 0
        }
        
        if not severities:
            return 'UNKNOWN'
        
        highest = 'UNKNOWN'
        highest_priority = 0
        
        for severity in severities:
            severity_str = str(severity).upper()
            priority = severity_priority.get(severity_str, 0)
            if priority > highest_priority:
                highest_priority = priority
                highest = severity_str
        
        return highest