"""
Columns O & P: NIST NVD Processor

Column O: NIST NVD Lookup URL
Column P: NIST NVD Lookup Result

Integrates with our AI-based NVD sandbox for comprehensive vulnerability scanning.
Based on retired version's sophisticated NVD processing logic.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.nvd import NVDSandbox
from ....core.sandbox_manager import SandboxManager


class NISTNVDProcessor:
    """Processor for Columns O & P - NIST NVD Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for NVD scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column O: NIST NVD Lookup URL
        
        Generates the search URL for NIST NVD database.
        Based on retired version's URL generation logic.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with NVD URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column O (nist_nvd_url) for {package_name}")
            
            # Generate NVD search URL following retired version's pattern
            base_url = "https://nvd.nist.gov/vuln/search/results"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?form_type=Basic&results_type=overview&query={search_query}&search_type=all&isCpeNameSearch=false"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "NVD NIST"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'NIST NVD search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column O for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error generating NVD URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column P: NIST NVD Lookup Result
        
        Performs actual vulnerability scanning using our AI-based NVD sandbox.
        Based on retired version's sophisticated NVD analysis.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with NVD scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column P (nist_nvd_result) for {package_name} v{current_version}")
            
            # Get NVD sandbox from our AI infrastructure
            nvd_sandbox = await self.sandbox_manager.get_sandbox('nvd')
            if not nvd_sandbox:
                return {
                    'value': 'NVD scanner not available',
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': 'NVD sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced NVD sandbox
            scan_result = await nvd_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'critical',
                    'font': 'critical',
                    'note': f'NVD scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's classification logic
            classification = self._classify_nvd_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column P for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error during NVD scan: {str(e)}'
            }
    
    def _classify_nvd_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify NVD scan results using retired version's sophisticated logic.
        
        Implements the 4-tier classification system:
        1. vulnerable - Confirmed security risks
        2. safe - CVEs found but current version not affected  
        3. manual_review - Requires human assessment
        4. none_found - No relevant vulnerabilities
        """
        vuln_count = scan_result.total_vulnerabilities
        
        # No vulnerabilities found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No NVD vulnerabilities found',
                'severity': 'NONE'
            }
        
        # Analyze vulnerability relevance using AI analysis
        relevant_vulns = 0
        max_severity = 'LOW'
        version_affected = False
        
        for vuln in scan_result.vulnerabilities:
            # Check if vulnerability affects current version
            if self._is_version_affected(vuln, current_version):
                version_affected = True
                relevant_vulns += 1
                if vuln.severity_level.value > max_severity:
                    max_severity = vuln.severity_level.value
        
        # Apply retired version's classification logic
        if relevant_vulns > 0 and version_affected:
            # Confirmed vulnerabilities affecting current version
            severity_text = max_severity.upper()
            return {
                'status': 'vulnerable',
                'summary': f'VULNERABLE - {relevant_vulns} CVEs affect v{current_version}',
                'color': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'font': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'note': f'{relevant_vulns} NVD vulnerabilities affect current version ({severity_text})',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # CVEs found but current version not affected (following retired version's SAFE classification)
            return {
                'status': 'safe',
                'summary': f'SAFE - {vuln_count} CVEs found but v{current_version} not affected',
                'color': 'updated',
                'font': 'updated', 
                'note': f'{vuln_count} NVD CVEs found but current version not affected',
                'severity': 'NONE'
            }
        else:
            # Manual review required (edge case)
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} CVEs need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} NVD CVEs require manual assessment',
                'severity': 'UNKNOWN'
            }
    
    def _is_version_affected(self, vulnerability, current_version: str) -> bool:
        """
        Check if vulnerability affects the current version.
        
        Uses AI analysis and version range checking.
        """
        try:
            # Use vulnerability's affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_range(current_version, version_range):
                        return True
            
            # Fallback to confidence-based assessment
            if hasattr(vulnerability, 'confidence_level'):
                return vulnerability.confidence_level.value >= 0.7
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking version impact: {e}")
            return False
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version falls within vulnerability range."""
        try:
            from packaging import version as pkg_version
            
            # Simple range checking - could be enhanced
            if '<' in version_range:
                max_version = version_range.strip('<= ')
                return pkg_version.parse(version) < pkg_version.parse(max_version)
            elif '>' in version_range:
                min_version = version_range.strip('>= ')
                return pkg_version.parse(version) > pkg_version.parse(min_version)
            else:
                return version == version_range.strip()
                
        except Exception:
            return False