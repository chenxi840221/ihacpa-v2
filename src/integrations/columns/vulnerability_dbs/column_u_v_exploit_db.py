"""
Columns U & V: Exploit Database Processor

Column U: Exploit Database Lookup URL
Column V: Exploit Database Lookup Result

Integrates with our AI-based ExploitDB sandbox for public exploit detection.
Based on retired version's AI-powered analysis with manual review fallback.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.exploit_db import ExploitDBScanner
from ....core.sandbox_manager import SandboxManager


class ExploitDBProcessor:
    """Processor for Columns U & V - Exploit Database Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for ExploitDB scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column U: Exploit Database Lookup URL
        
        Generates the search URL for Exploit Database.
        Based on retired version's ExploitDB URL generation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with ExploitDB URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column U (exploit_db_url) for {package_name}")
            
            # Generate Exploit Database search URL following retired version's pattern
            base_url = "https://www.exploit-db.com/search"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?text={search_query}"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "Exploit-DB"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'Exploit Database search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column U for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error generating ExploitDB URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column V: Exploit Database Lookup Result
        
        Performs actual exploit detection using our AI-based ExploitDB sandbox.
        Based on retired version's AI-powered analysis with severity escalation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with ExploitDB scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column V (exploit_db_result) for {package_name} v{current_version}")
            
            # Get ExploitDB sandbox from our AI infrastructure
            exploit_db_sandbox = await self.sandbox_manager.get_sandbox('exploit_db')
            if not exploit_db_sandbox:
                return {
                    'value': 'ExploitDB scanner not available',
                    'color': 'not_available',
                    'font': 'not_available',
                    'note': 'ExploitDB sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced ExploitDB sandbox
            scan_result = await exploit_db_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'security_risk',
                    'font': 'security_risk',
                    'note': f'ExploitDB scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's AI-powered exploit classification
            classification = self._classify_exploit_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'ai_analysis': classification.get('ai_analysis', ''),
                'exploit_detection': True,  # This scanner focuses on public exploits
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column V for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error during ExploitDB scan: {str(e)}'
            }
    
    def _classify_exploit_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify ExploitDB scan results using retired version's sophisticated logic.
        
        ExploitDB focuses on public exploits which represent immediate security risks.
        Implements the same 4-tier classification system as the old version with 
        enhanced AI-powered analysis and severity escalation for public exploits.
        """
        vuln_count = scan_result.total_vulnerabilities
        ai_analysis = scan_result.metadata.get('ai_analysis', '') if scan_result.metadata else ''
        
        # Handle NEW packages (special case from old version)
        if current_version == "NEW":
            if vuln_count > 0:
                exploit_ids = [getattr(v, 'id', f'Exploit-{i+1}') for i, v in enumerate(scan_result.vulnerabilities[:8])]
                if vuln_count > 8:
                    exploit_ids.append(f"... and {vuln_count-8} more")
                summary = f"NEW package - Found {vuln_count} exploit records: {', '.join(exploit_ids)}"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'NEW package with {vuln_count} exploit records requires assessment',
                    'severity': 'UNKNOWN',
                    'ai_analysis': ai_analysis
                }
            else:
                return {
                    'status': 'none_found',
                    'summary': 'NEW package - No exploit records found',
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': 'No public exploits found for NEW package',
                    'severity': 'NONE',
                    'ai_analysis': ai_analysis
                }
        
        # Check for AI analysis results (enhanced from retired version)
        if ai_analysis:
            ai_lower = ai_analysis.lower()
            
            # AI detected no exploits
            if 'not_found' in ai_lower or 'no exploits found' in ai_lower:
                return {
                    'status': 'none_found',
                    'summary': 'SAFE - No exploits found (AI verified)',
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': 'No public exploits found via AI analysis',
                    'severity': 'NONE',
                    'ai_analysis': ai_analysis
                }
            
            # AI detected exploits - HIGH PRIORITY due to public exploit availability
            elif ': found' in ai_lower and 'not_found' not in ai_lower:
                exploit_count = max(vuln_count, 1)
                return {
                    'status': 'vulnerable',
                    'summary': f'HIGH RISK - {exploit_count} public exploits found (AI detected)',
                    'color': 'security_risk',  # Always high priority for public exploits
                    'font': 'security_risk',
                    'note': f'{exploit_count} public exploits found - immediate security risk via AI analysis',
                    'severity': 'HIGH',  # Escalate severity for public exploits
                    'ai_analysis': ai_analysis
                }
        
        # No exploits found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No public exploits found in Exploit Database',
                'severity': 'NONE'
            }
        
        # Analyze exploit relevance and version impact using sophisticated logic
        affected_exploits = []
        version_check_indeterminate = False
        
        for vuln in scan_result.vulnerabilities:
            # Use enhanced version impact checking from old version
            version_impact = self._check_exploit_version_impact_enhanced(vuln, current_version, package_name)
            
            if version_impact is None:
                # Indeterminate - can't determine version impact for public exploit
                version_check_indeterminate = True
            elif version_impact:
                # Confirmed: current version is affected by public exploit
                affected_exploits.append(vuln)
        
        # Apply retired version's sophisticated classification logic
        if affected_exploits:
            # Confirmed public exploits affecting current version - CRITICAL PRIORITY
            max_severity = self._get_highest_severity([getattr(v, 'severity_level', 'HIGH') for v in affected_exploits])
            # Escalate severity for public exploits
            if max_severity in ['MEDIUM', 'LOW']:
                max_severity = 'HIGH'  # Public exploits are always elevated risk
            
            exploit_list = [getattr(v, 'id', f'EDB-{i+1}') for i, v in enumerate(affected_exploits[:3])]
            if len(affected_exploits) > 3:
                exploit_list.append(f"... and {len(affected_exploits)-3} more")
            
            summary = f"CRITICAL - {len(affected_exploits)} public exploits affect v{current_version} (Highest: {max_severity})"
            return {
                'status': 'vulnerable',
                'summary': summary,
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'{len(affected_exploits)} public exploits confirmed to affect current version: {", ".join(exploit_list)}',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # Public exploits found but current version not affected (SAFE case from old version)
            if version_check_indeterminate:
                # Some exploits couldn't be definitively checked
                summary = f"Manual review required - {vuln_count} exploits need assessment"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'{vuln_count} public exploits require manual version impact assessment',
                    'severity': 'UNKNOWN'
                }
            else:
                # All exploits checked and current version is safe
                exploit_list = [getattr(v, 'id', f'EDB-{i+1}') for i, v in enumerate(scan_result.vulnerabilities[:3])]
                if vuln_count > 3:
                    exploit_list.append(f"+{vuln_count - 3} more")
                
                return {
                    'status': 'safe',
                    'summary': f'SAFE - {vuln_count} exploits found but v{current_version} not affected',
                    'color': 'updated',
                    'font': 'updated',
                    'note': f'{vuln_count} public exploits found but current version not affected: {", ".join(exploit_list)}',
                    'severity': 'NONE'
                }
        else:
            # Edge case - manual review for public exploit database
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} exploits need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} public exploits require manual assessment (exploit database)',
                'severity': 'UNKNOWN'
            }
    
    def _is_exploit_version_specific(self, vulnerability, current_version: str) -> bool:
        """
        Check if exploit is specific to the current version.
        
        Public exploits that target specific versions pose higher immediate risk.
        """
        try:
            # Check if vulnerability mentions specific version
            if hasattr(vulnerability, 'description'):
                description = str(vulnerability.description).lower()
                version_lower = str(current_version).lower()
                
                # Look for version-specific indicators
                version_indicators = [
                    f"version {version_lower}",
                    f"v{version_lower}",
                    f"{version_lower} and",
                    f"through {version_lower}",
                    f"up to {version_lower}"
                ]
                
                if any(indicator in description for indicator in version_indicators):
                    return True
            
            # Check affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_exploit_range(current_version, version_range):
                        return True
            
            # Use AI confidence for version specificity
            if hasattr(vulnerability, 'confidence_level'):
                # High confidence suggests version-specific targeting
                return vulnerability.confidence_level.value >= 0.8
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking exploit version specificity: {e}")
            return False
    
    def _version_in_exploit_range(self, version: str, range_spec: str) -> bool:
        """Check if version falls within exploit's affected range."""
        try:
            from packaging import version as pkg_version
            
            # Ensure version is a string
            version_str = str(version)
            
            # Simple range checking for exploit data
            if '<' in range_spec:
                max_version = range_spec.strip('< =')
                return pkg_version.parse(version_str) < pkg_version.parse(max_version)
            elif '>' in range_spec:
                min_version = range_spec.strip('> =')
                return pkg_version.parse(version_str) > pkg_version.parse(min_version)
            elif '==' in range_spec:
                exact_version = range_spec.strip('= ')
                return pkg_version.parse(version_str) == pkg_version.parse(exact_version)
            else:
                return version_str == range_spec.strip()
                
        except Exception:
            return False
    
    def _check_exploit_version_impact_enhanced(self, vulnerability, current_version: str, package_name: str):
        """
        Enhanced version impact checking for ExploitDB from retired version.
        
        ExploitDB focuses on public exploits which require careful assessment
        since they represent immediate security risks with available exploit code.
        
        Returns:
            True: Current version is affected by public exploit
            False: Current version is not affected
            None: Cannot determine (indeterminate)
        """
        if not current_version or current_version == "NEW":
            return None
            
        try:
            from packaging import version
            current_ver = version.parse(current_version)
            
            # Check exploit's affected versions (public exploit targeting)
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_exploit_range(current_version, version_range):
                        return True
                return False
            
            # Check version specificity for public exploits
            if self._is_exploit_version_specific(vulnerability, current_version):
                return True
            
            # Use AI confidence for exploit targeting assessment
            if hasattr(vulnerability, 'confidence_level'):
                confidence = vulnerability.confidence_level.value if hasattr(vulnerability.confidence_level, 'value') else vulnerability.confidence_level
                # High confidence for public exploit targeting
                if confidence >= 0.8:
                    return True
                elif confidence <= 0.3:
                    return False
                else:
                    return None  # Indeterminate confidence for public exploit
            
            # No definitive version information available for public exploit
            return None
            
        except Exception as e:
            self.logger.warning(f"Error in enhanced ExploitDB version checking for {package_name}: {e}")
            return None
    
    def _get_highest_severity(self, severities):
        """Get the highest severity from a list of severities (from old version)"""
        severity_priority = {
            'CRITICAL': 4,
            'HIGH': 3,
            'MEDIUM': 2,
            'LOW': 1,
            'NONE': 0,
            'UNKNOWN': 0
        }
        
        if not severities:
            return 'UNKNOWN'
        
        highest = 'UNKNOWN'
        highest_priority = 0
        
        for severity in severities:
            severity_str = str(severity).upper()
            priority = severity_priority.get(severity_str, 0)
            if priority > highest_priority:
                highest_priority = priority
                highest = severity_str
        
        return highest