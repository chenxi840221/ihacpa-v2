"""
Columns U & V: Exploit Database Processor

Column U: Exploit Database Lookup URL
Column V: Exploit Database Lookup Result

Integrates with our AI-based ExploitDB sandbox for public exploit detection.
Based on retired version's AI-powered analysis with manual review fallback.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.exploit_db import ExploitDBScanner
from ....core.sandbox_manager import SandboxManager


class ExploitDBProcessor:
    """Processor for Columns U & V - Exploit Database Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for ExploitDB scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column U: Exploit Database Lookup URL
        
        Generates the search URL for Exploit Database.
        Based on retired version's ExploitDB URL generation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with ExploitDB URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column U (exploit_db_url) for {package_name}")
            
            # Generate Exploit Database search URL following retired version's pattern
            base_url = "https://www.exploit-db.com/search"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?text={search_query}"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "Exploit-DB"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'Exploit Database search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column U for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error generating ExploitDB URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column V: Exploit Database Lookup Result
        
        Performs actual exploit detection using our AI-based ExploitDB sandbox.
        Based on retired version's AI-powered analysis with severity escalation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with ExploitDB scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column V (exploit_db_result) for {package_name} v{current_version}")
            
            # Get ExploitDB sandbox from our AI infrastructure
            exploit_db_sandbox = await self.sandbox_manager.get_sandbox('exploit_db')
            if not exploit_db_sandbox:
                return {
                    'value': 'ExploitDB scanner not available',
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': 'ExploitDB sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced ExploitDB sandbox
            scan_result = await exploit_db_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'critical',
                    'font': 'critical',
                    'note': f'ExploitDB scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's AI-powered exploit classification
            classification = self._classify_exploit_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'ai_analysis': classification.get('ai_analysis', ''),
                'exploit_detection': True,  # This scanner focuses on public exploits
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column V for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error during ExploitDB scan: {str(e)}'
            }
    
    def _classify_exploit_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify ExploitDB scan results using retired version's AI-powered analysis.
        
        ExploitDB classification is unique because:
        1. It focuses on public exploits (high severity implications)
        2. Uses AI analysis for sophisticated detection
        3. Has manual review fallback for complex cases
        4. Applies severity escalation for confirmed exploits
        """
        vuln_count = scan_result.total_vulnerabilities
        ai_analysis = scan_result.metadata.get('ai_analysis', '') if scan_result.metadata else ''
        
        # Check for AI analysis results (following retired version's pattern)
        if ai_analysis:
            ai_lower = ai_analysis.lower()
            
            # AI detected no exploits
            if 'not_found' in ai_lower or 'no exploits found' in ai_lower:
                return {
                    'status': 'none_found',
                    'summary': 'SAFE - No exploits found (AI verified)',
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': 'No public exploits found via AI analysis',
                    'severity': 'NONE',
                    'ai_analysis': ai_analysis
                }
            
            # AI detected exploits - HIGH PRIORITY due to public exploit availability
            elif ': found' in ai_lower and 'not_found' not in ai_lower:
                exploit_count = max(vuln_count, 1)
                return {
                    'status': 'vulnerable',
                    'summary': f'HIGH RISK - {exploit_count} public exploits found (AI detected)',
                    'color': 'security_risk',  # Always high priority for public exploits
                    'font': 'security_risk',
                    'note': f'{exploit_count} public exploits found - immediate security risk via AI analysis',
                    'severity': 'HIGH',  # Escalate severity for public exploits
                    'ai_analysis': ai_analysis
                }
        
        # No AI analysis available - use scan results
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No public exploits found in Exploit Database',
                'severity': 'NONE'
            }
        
        # Exploits found without AI analysis - apply conservative classification
        elif vuln_count > 0:
            # Analyze exploit severity and public availability
            max_severity = 'MEDIUM'  # Default for public exploits
            exploit_ids = []
            version_specific = False
            
            for vuln in scan_result.vulnerabilities:
                # Collect exploit IDs
                if hasattr(vuln, 'id') and ('EDB-' in vuln.id or 'exploit' in vuln.id.lower()):
                    exploit_ids.append(vuln.id)
                
                # Check version specificity
                if self._is_exploit_version_specific(vuln, current_version):
                    version_specific = True
                
                # Update severity
                if vuln.severity_level.value > max_severity:
                    max_severity = vuln.severity_level.value
            
            # Apply retired version's severity escalation for public exploits
            if version_specific or max_severity in ['HIGH', 'CRITICAL']:
                # High risk - version-specific or high-severity public exploits
                exploit_list = ', '.join(exploit_ids[:2])
                if len(exploit_ids) > 2:
                    exploit_list += f", +{len(exploit_ids) - 2} more"
                
                return {
                    'status': 'vulnerable',
                    'summary': f'HIGH RISK - {vuln_count} public exploits affect v{current_version}',
                    'color': 'security_risk',
                    'font': 'security_risk',
                    'note': f'{vuln_count} version-specific public exploits found: {exploit_list} (HIGH RISK)',
                    'severity': 'HIGH'  # Escalated due to public exploit availability
                }
            else:
                # Moderate risk - general exploits requiring manual review
                exploit_list = ', '.join(exploit_ids[:2])
                if len(exploit_ids) > 2:
                    exploit_list += f", +{len(exploit_ids) - 2} more"
                    
                return {
                    'status': 'manual_review',
                    'summary': f'Manual review required - {vuln_count} exploits need assessment',
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'{vuln_count} public exploits found but require manual assessment: {exploit_list}',
                    'severity': 'MEDIUM'
                }
        
        # Fallback - manual review required
        else:
            return {
                'status': 'manual_review',
                'summary': 'Manual review required',
                'color': 'version_update',
                'font': 'version_update',
                'note': 'ExploitDB scan requires manual review for assessment',
                'severity': 'UNKNOWN'
            }
    
    def _is_exploit_version_specific(self, vulnerability, current_version: str) -> bool:
        """
        Check if exploit is specific to the current version.
        
        Public exploits that target specific versions pose higher immediate risk.
        """
        try:
            # Check if vulnerability mentions specific version
            if hasattr(vulnerability, 'description'):
                description = str(vulnerability.description).lower()
                version_lower = current_version.lower()
                
                # Look for version-specific indicators
                version_indicators = [
                    f"version {version_lower}",
                    f"v{version_lower}",
                    f"{version_lower} and",
                    f"through {version_lower}",
                    f"up to {version_lower}"
                ]
                
                if any(indicator in description for indicator in version_indicators):
                    return True
            
            # Check affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_exploit_range(current_version, version_range):
                        return True
            
            # Use AI confidence for version specificity
            if hasattr(vulnerability, 'confidence_level'):
                # High confidence suggests version-specific targeting
                return vulnerability.confidence_level.value >= 0.8
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking exploit version specificity: {e}")
            return False
    
    def _version_in_exploit_range(self, version: str, range_spec: str) -> bool:
        """Check if version falls within exploit's affected range."""
        try:
            from packaging import version as pkg_version
            
            # Simple range checking for exploit data
            if '<' in range_spec:
                max_version = range_spec.strip('< =')
                return pkg_version.parse(version) < pkg_version.parse(max_version)
            elif '>' in range_spec:
                min_version = range_spec.strip('> =')
                return pkg_version.parse(version) > pkg_version.parse(min_version)
            elif '==' in range_spec:
                exact_version = range_spec.strip('= ')
                return pkg_version.parse(version) == pkg_version.parse(exact_version)
            else:
                return version == range_spec.strip()
                
        except Exception:
            return False