"""
Columns Q & R: MITRE CVE Processor

Column Q: MITRE CVE Lookup URL
Column R: MITRE CVE Lookup Result

Integrates with our AI-based MITRE sandbox for comprehensive CVE analysis.
Based on retired version's hybrid NIST API + MITRE reference approach.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.mitre import MITRESandbox
from ....core.sandbox_manager import SandboxManager


class MITRECVEProcessor:
    """Processor for Columns Q & R - MITRE CVE Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for MITRE scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column Q: MITRE CVE Lookup URL
        
        Generates the search URL for MITRE CVE database.
        Based on retired version's MITRE URL generation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with MITRE URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column Q (mitre_cve_url) for {package_name}")
            
            # Generate MITRE CVE search URL following retired version's pattern
            base_url = "https://cve.mitre.org/cgi-bin/cvekey.cgi"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?keyword={search_query}"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "CVE MITRE"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'MITRE CVE search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column Q for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error generating MITRE URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column R: MITRE CVE Lookup Result
        
        Performs actual CVE analysis using our AI-based MITRE sandbox.
        Based on retired version's hybrid data strategy and authoritative CVE analysis.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with MITRE scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column R (mitre_cve_result) for {package_name} v{current_version}")
            
            # Get MITRE sandbox from our AI infrastructure
            mitre_sandbox = await self.sandbox_manager.get_sandbox('mitre')
            if not mitre_sandbox:
                return {
                    'value': 'MITRE scanner not available',
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': 'MITRE sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced MITRE sandbox
            scan_result = await mitre_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'critical',
                    'font': 'critical',
                    'note': f'MITRE scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's authoritative CVE classification
            classification = self._classify_mitre_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'authoritative_source': True,  # MITRE is authoritative for CVEs
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column R for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error during MITRE scan: {str(e)}'
            }
    
    def _classify_mitre_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify MITRE CVE scan results using retired version's authoritative analysis.
        
        MITRE is the authoritative source for CVE data, so classification is more definitive.
        Implements the same 4-tier system but with higher confidence.
        """
        vuln_count = scan_result.total_vulnerabilities
        
        # No CVEs found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No MITRE CVEs found (authoritative)',
                'severity': 'NONE'
            }
        
        # Analyze CVE relevance and version impact
        relevant_cves = 0
        max_severity = 'LOW'
        version_affected = False
        cve_ids = []
        
        for vuln in scan_result.vulnerabilities:
            # Collect CVE IDs for reference
            if hasattr(vuln, 'id') and vuln.id.startswith('CVE-'):
                cve_ids.append(vuln.id)
            
            # Check if CVE affects current version using AI analysis
            if self._is_version_affected_mitre(vuln, current_version, package_name):
                version_affected = True
                relevant_cves += 1
                if vuln.severity_level.value > max_severity:
                    max_severity = vuln.severity_level.value
        
        # Apply retired version's authoritative classification logic
        if relevant_cves > 0 and version_affected:
            # Confirmed CVEs affecting current version (authoritative)
            severity_text = max_severity.upper()
            cve_list = ', '.join(cve_ids[:3])  # Show first 3 CVE IDs
            if len(cve_ids) > 3:
                cve_list += f", +{len(cve_ids) - 3} more"
            
            return {
                'status': 'vulnerable',
                'summary': f'VULNERABLE - {relevant_cves} CVEs affect v{current_version}',
                'color': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'font': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'note': f'{relevant_cves} MITRE CVEs affect current version: {cve_list} ({severity_text})',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # CVEs found but current version not affected (authoritative SAFE)
            cve_list = ', '.join(cve_ids[:3])
            if len(cve_ids) > 3:
                cve_list += f", +{len(cve_ids) - 3} more"
                
            return {
                'status': 'safe',
                'summary': f'SAFE - {vuln_count} CVEs found but v{current_version} not affected',
                'color': 'updated',
                'font': 'updated',
                'note': f'{vuln_count} MITRE CVEs found but current version not affected: {cve_list}',
                'severity': 'NONE'
            }
        else:
            # Edge case - manual review for authoritative source
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} CVEs need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} MITRE CVEs require manual assessment (authoritative source)',
                'severity': 'UNKNOWN'
            }
    
    def _is_version_affected_mitre(self, vulnerability, current_version: str, package_name: str) -> bool:
        """
        Check if CVE affects the current version using MITRE's authoritative data.
        
        Enhanced with retired version's Python package relevance checking.
        """
        try:
            # First, check if this CVE is relevant to the Python package
            if not self._is_python_cve_relevant(vulnerability, package_name):
                return False
            
            # Use vulnerability's affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_range(current_version, version_range):
                        return True
            
            # For MITRE (authoritative source), use higher confidence threshold
            if hasattr(vulnerability, 'confidence_level'):
                return vulnerability.confidence_level.value >= 0.8
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking MITRE CVE version impact: {e}")
            return False
    
    def _is_python_cve_relevant(self, vulnerability, package_name: str) -> bool:
        """
        Check if CVE is relevant to the Python package.
        
        Based on retired version's enhanced Python package relevance detection.
        """
        try:
            description = str(vulnerability.description).lower() if hasattr(vulnerability, 'description') else ''
            package_lower = package_name.lower()
            
            # Python package indicators (from retired version)
            python_indicators = [
                f"python {package_lower}",
                f"pip install {package_lower}",
                f"pypi {package_lower}",
                f"{package_lower} python package",
                f"{package_lower} python library",
                f"python's {package_lower}",
                f"python-{package_lower}",
                f"the {package_lower} package for python",
                f"the {package_lower} library for python"
            ]
            
            if any(indicator in description for indicator in python_indicators):
                return True
            
            # Hard exclusions (from retired version's logic)
            hard_exclusions = [
                "wordpress plugin", "wordpress theme", "drupal module", 
                "joomla extension", "php plugin", f"lib{package_lower}",
                f"{package_lower}.c", f"{package_lower}.h", f"{package_lower}.exe",
                "rust crate", "ruby gem", "perl module", "golang", "node.js", "npm package"
            ]
            
            if any(exclusion in description for exclusion in hard_exclusions):
                return False
            
            # Basic package name match
            return package_lower in description
            
        except Exception as e:
            self.logger.warning(f"Error checking CVE relevance: {e}")
            return True  # Conservative approach for authoritative source
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version falls within CVE vulnerability range."""
        try:
            from packaging import version as pkg_version
            
            # Enhanced range checking for MITRE data
            if '<' in version_range:
                max_version = version_range.strip('<= ')
                return pkg_version.parse(version) < pkg_version.parse(max_version)
            elif '>' in version_range:
                min_version = version_range.strip('>= ')
                return pkg_version.parse(version) > pkg_version.parse(min_version)
            elif '==' in version_range:
                exact_version = version_range.strip('= ')
                return pkg_version.parse(version) == pkg_version.parse(exact_version)
            else:
                return version == version_range.strip()
                
        except Exception:
            return False  # Conservative approach