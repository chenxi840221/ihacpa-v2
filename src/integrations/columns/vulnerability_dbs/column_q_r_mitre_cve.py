"""
Columns Q & R: MITRE CVE Processor

Column Q: MITRE CVE Lookup URL
Column R: MITRE CVE Lookup Result

Integrates with our AI-based MITRE sandbox for comprehensive CVE analysis.
Based on retired version's hybrid NIST API + MITRE reference approach.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.mitre import MITRESandbox
from ....core.sandbox_manager import SandboxManager


class MITRECVEProcessor:
    """Processor for Columns Q & R - MITRE CVE Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for MITRE scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column Q: MITRE CVE Lookup URL
        
        Generates the search URL for MITRE CVE database.
        Based on retired version's MITRE URL generation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with MITRE URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column Q (mitre_cve_url) for {package_name}")
            
            # Generate MITRE CVE search URL following retired version's pattern
            base_url = "https://cve.mitre.org/cgi-bin/cvekey.cgi"
            search_query = quote(f"{package_name} python")
            
            search_url = f"{base_url}?keyword={search_query}"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "CVE MITRE"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'MITRE CVE search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column Q for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error generating MITRE URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column R: MITRE CVE Lookup Result
        
        Performs actual CVE analysis using our AI-based MITRE sandbox.
        Based on retired version's hybrid data strategy and authoritative CVE analysis.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with MITRE scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column R (mitre_cve_result) for {package_name} v{current_version}")
            
            # Get MITRE sandbox from our AI infrastructure
            mitre_sandbox = await self.sandbox_manager.get_sandbox('mitre')
            if not mitre_sandbox:
                return {
                    'value': 'MITRE scanner not available',
                    'color': 'not_available',
                    'font': 'not_available',
                    'note': 'MITRE sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced MITRE sandbox
            scan_result = await mitre_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'security_risk',
                    'font': 'security_risk',
                    'note': f'MITRE scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's authoritative CVE classification
            classification = self._classify_mitre_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'authoritative_source': True,  # MITRE is authoritative for CVEs
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column R for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'Error during MITRE scan: {str(e)}'
            }
    
    def _classify_mitre_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify MITRE CVE scan results using retired version's sophisticated logic.
        
        MITRE is the authoritative source for CVE data, implementing the same
        sophisticated 4-tier classification system as the old version.
        """
        vuln_count = scan_result.total_vulnerabilities
        
        # Handle NEW packages (special case from old version)
        if current_version == "NEW":
            if vuln_count > 0:
                cve_list = [v.cve_id for v in scan_result.vulnerabilities[:15]]
                if vuln_count > 15:
                    cve_list.append(f"... and {vuln_count-15} more")
                summary = f"NEW package - Found {vuln_count} MITRE CVE records: {', '.join(cve_list)}"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'NEW package with {vuln_count} MITRE CVE records requires assessment',
                    'severity': 'UNKNOWN'
                }
            else:
                return {
                    'status': 'none_found',
                    'summary': 'NEW package - No MITRE CVE records found',
                    'color': 'new_data',
                    'font': 'new_data',
                    'note': 'No MITRE CVEs found for NEW package',
                    'severity': 'NONE'
                }
        
        # No CVEs found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No MITRE CVEs found (authoritative)',
                'severity': 'NONE'
            }
        
        # Analyze CVE relevance and version impact using sophisticated logic
        affected_cves = []
        version_check_indeterminate = False
        
        for vuln in scan_result.vulnerabilities:
            # Use enhanced version impact checking from old version
            version_impact = self._check_mitre_version_impact_enhanced(vuln, current_version, package_name)
            
            if version_impact is None:
                # Indeterminate - can't determine version impact
                version_check_indeterminate = True
            elif version_impact:
                # Confirmed: current version is affected
                affected_cves.append(vuln)
        
        # Apply retired version's sophisticated classification logic
        if affected_cves:
            # Confirmed CVEs affecting current version
            max_severity = self._get_highest_severity([v.severity_level.value for v in affected_cves])
            cve_list = [v.cve_id for v in affected_cves[:3]]
            if len(affected_cves) > 3:
                cve_list.append(f"... and {len(affected_cves)-3} more")
            
            summary = f"VULNERABLE - {len(affected_cves)} MITRE CVEs affect v{current_version} (Highest: {max_severity})"
            return {
                'status': 'vulnerable',
                'summary': summary,
                'color': 'security_risk',
                'font': 'security_risk',
                'note': f'{len(affected_cves)} MITRE CVEs confirmed to affect current version: {", ".join(cve_list)}',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # CVEs found but current version not affected (SAFE case from old version)
            if version_check_indeterminate:
                # Some CVEs couldn't be definitively checked
                summary = f"Manual review required - {vuln_count} MITRE CVEs need assessment"
                return {
                    'status': 'manual_review',
                    'summary': summary,
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': f'{vuln_count} MITRE CVEs require manual version impact assessment',
                    'severity': 'UNKNOWN'
                }
            else:
                # All CVEs checked and current version is safe
                cve_list = [v.cve_id for v in scan_result.vulnerabilities[:3]]
                if vuln_count > 3:
                    cve_list.append(f"+{vuln_count - 3} more")
                
                return {
                    'status': 'safe',
                    'summary': f'SAFE - {vuln_count} CVEs found but v{current_version} not affected',
                    'color': 'updated',
                    'font': 'updated',
                    'note': f'{vuln_count} MITRE CVEs found but current version not affected: {", ".join(cve_list)}',
                    'severity': 'NONE'
                }
        else:
            # Edge case - manual review for authoritative source
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} CVEs need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} MITRE CVEs require manual assessment (authoritative source)',
                'severity': 'UNKNOWN'
            }
    
    def _is_version_affected_mitre(self, vulnerability, current_version: str, package_name: str) -> bool:
        """
        Check if CVE affects the current version using MITRE's authoritative data.
        
        Enhanced with retired version's Python package relevance checking.
        """
        try:
            # First, check if this CVE is relevant to the Python package
            if not self._is_python_cve_relevant(vulnerability, package_name):
                return False
            
            # Use vulnerability's affected versions if available
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_range(current_version, version_range):
                        return True
            
            # For MITRE (authoritative source), use higher confidence threshold
            if hasattr(vulnerability, 'confidence_level'):
                return vulnerability.confidence_level.value >= 0.8
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking MITRE CVE version impact: {e}")
            return False
    
    def _is_python_cve_relevant(self, vulnerability, package_name: str) -> bool:
        """
        Check if CVE is relevant to the Python package.
        
        Based on retired version's enhanced Python package relevance detection.
        """
        try:
            description = str(vulnerability.description).lower() if hasattr(vulnerability, 'description') else ''
            package_lower = package_name.lower()
            
            # Python package indicators (from retired version)
            python_indicators = [
                f"python {package_lower}",
                f"pip install {package_lower}",
                f"pypi {package_lower}",
                f"{package_lower} python package",
                f"{package_lower} python library",
                f"python's {package_lower}",
                f"python-{package_lower}",
                f"the {package_lower} package for python",
                f"the {package_lower} library for python"
            ]
            
            if any(indicator in description for indicator in python_indicators):
                return True
            
            # Hard exclusions (from retired version's logic)
            hard_exclusions = [
                "wordpress plugin", "wordpress theme", "drupal module", 
                "joomla extension", "php plugin", f"lib{package_lower}",
                f"{package_lower}.c", f"{package_lower}.h", f"{package_lower}.exe",
                "rust crate", "ruby gem", "perl module", "golang", "node.js", "npm package"
            ]
            
            if any(exclusion in description for exclusion in hard_exclusions):
                return False
            
            # Basic package name match
            return package_lower in description
            
        except Exception as e:
            self.logger.warning(f"Error checking CVE relevance: {e}")
            return True  # Conservative approach for authoritative source
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version falls within CVE vulnerability range."""
        try:
            from packaging import version as pkg_version
            
            # Enhanced range checking for MITRE data
            if '<' in version_range:
                max_version = version_range.strip('<= ')
                return pkg_version.parse(version) < pkg_version.parse(max_version)
            elif '>' in version_range:
                min_version = version_range.strip('>= ')
                return pkg_version.parse(version) > pkg_version.parse(min_version)
            elif '==' in version_range:
                exact_version = version_range.strip('= ')
                return pkg_version.parse(version) == pkg_version.parse(exact_version)
            else:
                return version == version_range.strip()
                
        except Exception:
            return False  # Conservative approach
    
    def _check_mitre_version_impact_enhanced(self, vulnerability, current_version: str, package_name: str):
        """
        Enhanced version impact checking for MITRE CVEs from retired version.
        
        Returns:
            True: Current version is affected
            False: Current version is not affected
            None: Cannot determine (indeterminate)
        """
        if not current_version or current_version == "NEW":
            return None
            
        try:
            from packaging import version
            current_ver = version.parse(current_version)
            
            # Check MITRE's affected versions data (authoritative source)
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._version_in_range(current_version, version_range):
                        return True
                return False
            
            # Use MITRE's confidence assessment (authoritative CVE data)
            if hasattr(vulnerability, 'confidence_level'):
                confidence = vulnerability.confidence_level.value if hasattr(vulnerability.confidence_level, 'value') else vulnerability.confidence_level
                # High confidence for MITRE (authoritative source)
                if confidence >= 0.8:
                    return True
                elif confidence <= 0.3:
                    return False
                else:
                    return None  # Indeterminate confidence
            
            # No definitive version information available from authoritative source
            return None
            
        except Exception as e:
            self.logger.warning(f"Error in enhanced MITRE version checking for {package_name}: {e}")
            return None
    
    def _get_highest_severity(self, severities):
        """Get the highest severity from a list of severities (from old version)"""
        severity_priority = {
            'CRITICAL': 4,
            'HIGH': 3,
            'MEDIUM': 2,
            'LOW': 1,
            'NONE': 0,
            'UNKNOWN': 0
        }
        
        if not severities:
            return 'UNKNOWN'
        
        highest = 'UNKNOWN'
        highest_priority = 0
        
        for severity in severities:
            severity_str = str(severity).upper()
            priority = severity_priority.get(severity_str, 0)
            if priority > highest_priority:
                highest_priority = priority
                highest = severity_str
        
        return highest