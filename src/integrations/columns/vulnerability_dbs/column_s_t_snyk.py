"""
Columns S & T: SNYK Processor

Column S: SNYK Vulnerability Lookup URL
Column T: SNYK Vulnerability Lookup Result

Integrates with our AI-based SNYK sandbox for commercial vulnerability intelligence.
Based on retired version's interval notation parsing and mathematical range logic.
"""

import logging
from typing import Dict, Any, Optional
from urllib.parse import quote
from ....sandboxes.snyk import SNYKSandbox
from ....core.sandbox_manager import SandboxManager


class SNYKProcessor:
    """Processor for Columns S & T - SNYK Vulnerability Scanning"""
    
    def __init__(self, sandbox_manager: SandboxManager):
        """
        Initialize processor.
        
        Args:
            sandbox_manager: Sandbox manager for SNYK scanning
        """
        self.sandbox_manager = sandbox_manager
        self.logger = logging.getLogger(__name__)
    
    async def process_url(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column S: SNYK Vulnerability Lookup URL
        
        Generates the search URL for SNYK vulnerability database.
        Based on retired version's SNYK URL generation.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with SNYK URL information and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column S (snyk_url) for {package_name}")
            
            # Generate SNYK search URL following retired version's pattern
            base_url = "https://security.snyk.io/vuln/pip"
            search_query = quote(package_name)
            
            search_url = f"{base_url}?search={search_query}"
            
            # Generate Excel hyperlink formula (following retired version's pattern)
            display_name = "Snyk"
            hyperlink_formula = f'=HYPERLINK("{search_url}", "{display_name}")'
            
            return {
                'value': hyperlink_formula,
                'color': 'updated',
                'font': 'updated',
                'note': f'SNYK vulnerability search URL for {package_name}',
                'hyperlink': search_url,
                'search_query': search_query
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column S for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error generating SNYK URL: {str(e)}'
            }
    
    async def process_result(self, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Process Column T: SNYK Vulnerability Lookup Result
        
        Performs actual vulnerability analysis using our AI-based SNYK sandbox.
        Based on retired version's interval notation parsing and semantic version comparison.
        
        Args:
            package_name: Name of the Python package
            current_version: Current version being analyzed
            
        Returns:
            Dictionary with SNYK scan results and cell formatting
        """
        try:
            self.logger.debug(f"Processing Column T (snyk_result) for {package_name} v{current_version}")
            
            # Get SNYK sandbox from our AI infrastructure
            snyk_sandbox = await self.sandbox_manager.get_sandbox('snyk')
            if not snyk_sandbox:
                return {
                    'value': 'SNYK scanner not available',
                    'color': 'version_update',
                    'font': 'version_update',
                    'note': 'SNYK sandbox not accessible'
                }
            
            # Perform scan using our AI-enhanced SNYK sandbox
            scan_result = await snyk_sandbox.scan_package(
                package_name=package_name,
                version=current_version
            )
            
            if not scan_result or not scan_result.success:
                return {
                    'value': 'Scan failed',
                    'color': 'critical',
                    'font': 'critical',
                    'note': f'SNYK scan failed: {scan_result.error_message if scan_result else "Unknown error"}'
                }
            
            # Analyze results using retired version's SNYK-specific classification
            classification = self._classify_snyk_result(scan_result, package_name, current_version)
            
            return {
                'value': classification['summary'],
                'color': classification['color'],
                'font': classification['font'],
                'note': classification['note'],
                'vulnerability_count': scan_result.total_vulnerabilities,
                'found_vulnerabilities': scan_result.total_vulnerabilities > 0,
                'classification_status': classification['status'],
                'severity': classification.get('severity', 'NONE'),
                'commercial_intel': True,  # SNYK provides commercial intelligence
                'scan_metadata': scan_result.metadata
            }
            
        except Exception as e:
            self.logger.error(f"Error processing Column T for {package_name}: {e}")
            return {
                'value': 'Error',
                'color': 'critical',
                'font': 'critical',
                'note': f'Error during SNYK scan: {str(e)}'
            }
    
    def _classify_snyk_result(self, scan_result, package_name: str, current_version: str) -> Dict[str, Any]:
        """
        Classify SNYK scan results using retired version's interval notation parsing logic.
        
        SNYK uses sophisticated interval notation for version ranges, requiring
        mathematical range logic and semantic version comparison.
        """
        vuln_count = scan_result.total_vulnerabilities
        
        # No vulnerabilities found
        if vuln_count == 0:
            return {
                'status': 'none_found',
                'summary': 'SAFE - None found',
                'color': 'new_data',
                'font': 'new_data',
                'note': 'No SNYK vulnerabilities found',
                'severity': 'NONE'
            }
        
        # Analyze vulnerability ranges using SNYK's interval notation
        vulnerable_count = 0
        max_severity = 'LOW'
        version_affected = False
        snyk_ids = []
        
        for vuln in scan_result.vulnerabilities:
            # Collect SNYK IDs for reference
            if hasattr(vuln, 'id') and 'SNYK-' in vuln.id:
                snyk_ids.append(vuln.id)
            
            # Check if vulnerability affects current version using SNYK's interval logic
            if self._is_version_in_snyk_range(vuln, current_version):
                version_affected = True
                vulnerable_count += 1
                if vuln.severity_level.value > max_severity:
                    max_severity = vuln.severity_level.value
        
        # Apply retired version's SNYK classification logic
        if vulnerable_count > 0 and version_affected:
            # Confirmed vulnerabilities in current version (SNYK commercial analysis)
            severity_text = max_severity.upper()
            snyk_list = ', '.join(snyk_ids[:2])  # Show first 2 SNYK IDs
            if len(snyk_ids) > 2:
                snyk_list += f", +{len(snyk_ids) - 2} more"
            
            return {
                'status': 'vulnerable',
                'summary': f'VULNERABLE - {vulnerable_count} issues in v{current_version}',
                'color': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'font': 'security_risk' if max_severity in ['HIGH', 'CRITICAL'] else 'version_update',
                'note': f'{vulnerable_count} SNYK vulnerabilities affect v{current_version}: {snyk_list} ({severity_text})',
                'severity': max_severity
            }
        elif vuln_count > 0:
            # Vulnerabilities found but current version not in affected ranges
            snyk_list = ', '.join(snyk_ids[:2])
            if len(snyk_ids) > 2:
                snyk_list += f", +{len(snyk_ids) - 2} more"
                
            return {
                'status': 'safe',
                'summary': f'SAFE - {vuln_count} issues found but v{current_version} not affected',
                'color': 'updated',
                'font': 'updated',
                'note': f'{vuln_count} SNYK vulnerabilities found but v{current_version} not in affected ranges: {snyk_list}',
                'severity': 'NONE'
            }
        else:
            # Edge case - requires assessment
            return {
                'status': 'manual_review',
                'summary': f'Manual review required - {vuln_count} issues need assessment',
                'color': 'version_update',
                'font': 'version_update',
                'note': f'{vuln_count} SNYK vulnerabilities require version range assessment',
                'severity': 'UNKNOWN'
            }
    
    def _is_version_in_snyk_range(self, vulnerability, current_version: str) -> bool:
        """
        Check if version falls within SNYK's vulnerability range.
        
        Based on retired version's interval notation parsing and mathematical range logic.
        SNYK uses sophisticated version range specifications.
        """
        try:
            # Get affected version ranges from vulnerability
            if hasattr(vulnerability, 'affected_versions') and vulnerability.affected_versions:
                for version_range in vulnerability.affected_versions:
                    if self._parse_snyk_interval_notation(current_version, version_range):
                        return True
            
            # Use AI confidence for SNYK commercial intelligence
            if hasattr(vulnerability, 'confidence_level'):
                # SNYK provides commercial-grade analysis, so use higher threshold
                return vulnerability.confidence_level.value >= 0.75
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Error checking SNYK version range: {e}")
            return False
    
    def _parse_snyk_interval_notation(self, version: str, range_spec: str) -> bool:
        """
        Parse SNYK's interval notation for version ranges.
        
        Based on retired version's mathematical range logic and multi-range processing.
        SNYK uses complex interval notation like: [1.0.0, 2.0.0), >=1.5.0,<2.0.0, etc.
        """
        try:
            from packaging import version as pkg_version
            current_ver = pkg_version.parse(version)
            
            # Handle multiple ranges separated by commas
            if ',' in range_spec:
                ranges = [r.strip() for r in range_spec.split(',')]
                return any(self._check_single_range(current_ver, r) for r in ranges)
            else:
                return self._check_single_range(current_ver, range_spec.strip())
                
        except Exception as e:
            self.logger.warning(f"Error parsing SNYK interval notation '{range_spec}': {e}")
            return False
    
    def _check_single_range(self, current_ver, range_spec: str) -> bool:
        """
        Check if version falls within a single range specification.
        
        Handles SNYK's various interval notations:
        - [a,b] - closed interval (inclusive both ends)
        - (a,b) - open interval (exclusive both ends)  
        - [a,b) - half-open (inclusive start, exclusive end)
        - (a,b] - half-open (exclusive start, inclusive end)
        - >=a,<b - explicit inequality notation
        """
        try:
            from packaging import version as pkg_version
            
            # Handle explicit inequality notation (>=a,<b format)
            if '>=' in range_spec and '<' in range_spec:
                parts = range_spec.replace('>=', '').split('<')
                if len(parts) == 2:
                    min_ver = pkg_version.parse(parts[0].strip())
                    max_ver = pkg_version.parse(parts[1].strip())
                    return min_ver <= current_ver < max_ver
            
            # Handle bracket notation [a,b], (a,b), etc.
            if '[' in range_spec or '(' in range_spec:
                # Extract start bracket, versions, and end bracket
                start_inclusive = range_spec.startswith('[')
                end_inclusive = range_spec.endswith(']')
                
                # Remove brackets and split by comma
                clean_spec = range_spec.strip('[]()').strip()
                if ',' in clean_spec:
                    versions = [v.strip() for v in clean_spec.split(',')]
                    if len(versions) == 2:
                        min_ver = pkg_version.parse(versions[0])
                        max_ver = pkg_version.parse(versions[1])
                        
                        # Apply inclusive/exclusive logic
                        min_check = current_ver >= min_ver if start_inclusive else current_ver > min_ver
                        max_check = current_ver <= max_ver if end_inclusive else current_ver < max_ver
                        
                        return min_check and max_check
            
            # Handle simple comparison operators
            if range_spec.startswith('>='):
                min_ver = pkg_version.parse(range_spec[2:].strip())
                return current_ver >= min_ver
            elif range_spec.startswith('>'):
                min_ver = pkg_version.parse(range_spec[1:].strip())
                return current_ver > min_ver
            elif range_spec.startswith('<='):
                max_ver = pkg_version.parse(range_spec[2:].strip())
                return current_ver <= max_ver
            elif range_spec.startswith('<'):
                max_ver = pkg_version.parse(range_spec[1:].strip())
                return current_ver < max_ver
            elif range_spec.startswith('=='):
                exact_ver = pkg_version.parse(range_spec[2:].strip())
                return current_ver == exact_ver
            else:
                # Exact match
                exact_ver = pkg_version.parse(range_spec)
                return current_ver == exact_ver
                
        except Exception as e:
            self.logger.warning(f"Error checking range '{range_spec}': {e}")
            return False
        
        return False