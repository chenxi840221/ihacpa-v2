"""
Exploit Database Scanner for IHACPA v2.0

Provides scanning capabilities for the Exploit Database to find public exploits
for Python packages and their vulnerabilities.
"""

import asyncio
import aiohttp
from datetime import datetime
from typing import Dict, List, Optional, Any
import logging
import re
from urllib.parse import quote

from ...core.base_scanner import BaseSandbox, ScanResult, VulnerabilityInfo, SeverityLevel


class ExploitDBScanner(BaseSandbox):
    """Scanner for Exploit Database (exploit-db.com)"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize Exploit Database scanner.
        
        Args:
            config: Scanner configuration
        """
        super().__init__("exploit_db", config or {})
        self.base_url = self.config.get('base_url', 'https://www.exploit-db.com')
        self.search_endpoint = f"{self.base_url}/search"
        self.api_endpoint = f"{self.base_url}/api/v1/search"
        self.timeout = self.config.get('timeout', 30)
        self.max_results = self.config.get('max_results', 50)
        self.session: Optional[aiohttp.ClientSession] = None
        self.logger = logging.getLogger(__name__)
        
    async def initialize(self) -> bool:
        """Initialize the scanner"""
        try:
            timeout = aiohttp.ClientTimeout(total=self.timeout)
            self.session = aiohttp.ClientSession(timeout=timeout)
            
            # Test connectivity
            test_url = f"{self.base_url}/robots.txt"
            async with self.session.get(test_url) as response:
                if response.status == 200:
                    self.logger.info("âœ… ExploitDB scanner initialized successfully")
                    return True
                else:
                    self.logger.warning(f"ExploitDB connectivity test failed: HTTP {response.status}")
                    return False
                    
        except Exception as e:
            self.logger.error(f"Failed to initialize ExploitDB scanner: {e}")
            return False
    
    async def cleanup(self):
        """Clean up resources"""
        if self.session:
            await self.session.close()
            self.session = None
    
    async def scan_package(self, package_name: str, version: Optional[str] = None, 
                          **kwargs) -> ScanResult:
        """
        Scan for exploits related to a Python package.
        
        Args:
            package_name: Name of the Python package
            version: Optional version string
            **kwargs: Additional scan parameters
            
        Returns:
            Scan results
        """
        try:
            if not self.session:
                await self.initialize()
            
            self.logger.debug(f"Scanning ExploitDB for {package_name}")
            
            # Search for exploits
            exploits = await self._search_exploits(package_name, version)
            print(f"ðŸ” ExploitDB search for '{package_name}': found {len(exploits)} exploits")
            
            # Convert to vulnerability format
            vulnerabilities = []
            for exploit in exploits:
                # Convert severity string to SeverityLevel enum
                severity_str = exploit.get('severity', 'MEDIUM').lower()
                severity = SeverityLevel.UNKNOWN
                if severity_str == 'critical':
                    severity = SeverityLevel.CRITICAL
                elif severity_str == 'high':
                    severity = SeverityLevel.HIGH
                elif severity_str == 'medium':
                    severity = SeverityLevel.MEDIUM
                elif severity_str == 'low':
                    severity = SeverityLevel.LOW
                
                vuln_info = VulnerabilityInfo(
                    cve_id=exploit.get('cve_ids', [None])[0] if exploit.get('cve_ids') else f"EDB-{exploit.get('id', package_name)}",
                    title=exploit.get('title', 'Exploit found'),
                    description=exploit.get('description', ''),
                    severity=severity,
                    cvss_score=exploit.get('cvss_score'),
                    affected_versions=exploit.get('affected_versions', []),
                    published_date=exploit.get('published_date'),
                    references=exploit.get('references', []),
                    source_url=exploit.get('url', self.base_url)
                )
                vulnerabilities.append(vuln_info)
            
            print(f"ðŸ“Š ExploitDB: {len(vulnerabilities)} exploits for {package_name}")
            
            # Create scan result
            result = ScanResult(
                package_name=package_name,
                source="ExploitDB",
                scan_time=datetime.now(),
                success=True,
                vulnerabilities=vulnerabilities,
                metadata={
                    'search_query': package_name,
                    'exploits_found': len(exploits),
                    'base_url': self.base_url,
                    'package_version': version
                }
            )
            
            self.logger.info(f"ExploitDB scan completed for {package_name}: {len(vulnerabilities)} exploits found")
            return result
            
        except Exception as e:
            self.logger.error(f"ExploitDB scan failed for {package_name}: {e}")
            return ScanResult(
                package_name=package_name,
                source="ExploitDB",
                scan_time=datetime.now(),
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                metadata={
                    'package_version': version
                }
            )
    
    async def _search_exploits(self, package_name: str, version: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Search for exploits related to the package.
        
        Args:
            package_name: Package name to search for
            version: Optional version string
            
        Returns:
            List of exploit information dictionaries
        """
        exploits = []
        
        try:
            # Try multiple search strategies
            search_queries = [
                package_name,
                f"python {package_name}",
                f"{package_name} python",
            ]
            
            if version:
                search_queries.extend([
                    f"{package_name} {version}",
                    f"python {package_name} {version}"
                ])
            
            for query in search_queries[:3]:  # Limit to first 3 queries
                query_exploits = await self._search_query(query)
                exploits.extend(query_exploits)
                
                # Break if we found enough results
                if len(exploits) >= self.max_results:
                    break
                    
                # Small delay between queries
                await asyncio.sleep(0.5)
            
            # Remove duplicates based on ID
            seen_ids = set()
            unique_exploits = []
            for exploit in exploits:
                exploit_id = exploit.get('id', exploit.get('title', ''))
                if exploit_id not in seen_ids:
                    seen_ids.add(exploit_id)
                    unique_exploits.append(exploit)
            
            return unique_exploits[:self.max_results]
            
        except Exception as e:
            self.logger.error(f"Exploit search failed for {package_name}: {e}")
            return []
    
    async def _search_query(self, query: str) -> List[Dict[str, Any]]:
        """
        Execute a search query against ExploitDB.
        
        Args:
            query: Search query string
            
        Returns:
            List of exploit results
        """
        try:
            # Try API endpoint first
            try:
                return await self._search_api(query)
            except Exception as e:
                self.logger.debug(f"API search failed, trying web search: {e}")
                return await self._search_web(query)
                
        except Exception as e:
            self.logger.error(f"Search query '{query}' failed: {e}")
            return []
    
    async def _search_api(self, query: str) -> List[Dict[str, Any]]:
        """Search using ExploitDB API if available"""
        search_url = f"{self.api_endpoint}?query={quote(query)}"
        
        async with self.session.get(search_url) as response:
            if response.status == 200:
                data = await response.json()
                exploits = []
                
                for item in data.get('exploits', []):
                    exploit = {
                        'id': item.get('id', 'UNKNOWN'),
                        'title': item.get('title', ''),
                        'description': item.get('description', ''),
                        'type': item.get('type', ''),
                        'platform': item.get('platform', ''),
                        'date': item.get('date_published', ''),
                        'author': item.get('author', ''),
                        'url': f"{self.base_url}/exploits/{item.get('id', '')}",
                        'severity': 'HIGH',  # Exploits are generally high severity
                        'source': 'ExploitDB'
                    }
                    exploits.append(exploit)
                
                return exploits
            else:
                raise Exception(f"API returned HTTP {response.status}")
    
    async def _search_web(self, query: str) -> List[Dict[str, Any]]:
        """Search using web interface as fallback"""
        search_url = f"{self.search_endpoint}?search={quote(query)}"
        
        async with self.session.get(search_url) as response:
            if response.status == 200:
                content = await response.text()
                return self._parse_web_results(content, query)
            else:
                raise Exception(f"Web search returned HTTP {response.status}")
    
    def _parse_web_results(self, html_content: str, query: str) -> List[Dict[str, Any]]:
        """
        Parse web search results from HTML content.
        
        Args:
            html_content: HTML content from search page
            query: Original search query
            
        Returns:
            List of parsed exploit information
        """
        exploits = []
        
        try:
            # Simple pattern matching for exploit information
            # This is a basic implementation - could be enhanced with proper HTML parsing
            
            # Look for exploit table rows or entries
            exploit_patterns = [
                r'exploit[/-](\d+)',  # Exploit ID pattern
                r'EDB-ID:\s*(\d+)',   # EDB ID pattern
            ]
            
            exploit_ids = set()
            for pattern in exploit_patterns:
                matches = re.finditer(pattern, html_content, re.IGNORECASE)
                for match in matches:
                    exploit_ids.add(match.group(1))
            
            # Create exploit entries for found IDs
            for exploit_id in list(exploit_ids)[:10]:  # Limit to 10 results
                exploit = {
                    'id': f"EDB-{exploit_id}",
                    'title': f'Exploit {exploit_id} (found via search: {query})',
                    'description': f'Potential exploit found for query: {query}',
                    'url': f"{self.base_url}/exploits/{exploit_id}",
                    'severity': 'MEDIUM',
                    'source': 'ExploitDB',
                    'search_query': query
                }
                exploits.append(exploit)
            
            # If no specific exploits found but page contains relevant keywords
            if not exploits and any(keyword in html_content.lower() for keyword in ['exploit', 'vulnerability', 'poc']):
                exploits.append({
                    'id': f"EDB-SEARCH-{hash(query) % 10000}",
                    'title': f'Potential exploits found for {query}',
                    'description': f'Search results indicate potential security issues for {query}',
                    'url': f"{self.search_endpoint}?search={quote(query)}",
                    'severity': 'LOW',
                    'source': 'ExploitDB',
                    'search_query': query,
                    'note': 'Manual review recommended'
                })
            
            return exploits
            
        except Exception as e:
            self.logger.error(f"Failed to parse web results: {e}")
            return []
    
    async def health_check(self) -> bool:
        """Check if the scanner is healthy and can connect to ExploitDB"""
        try:
            if not self.session:
                await self.initialize()
            
            async with self.session.get(f"{self.base_url}/robots.txt") as response:
                return response.status == 200
                
        except Exception as e:
            self.logger.error(f"ExploitDB health check failed: {e}")
            return False
    
    def get_scanner_info(self) -> Dict[str, Any]:
        """Get information about this scanner"""
        return {
            'name': 'ExploitDB',
            'description': 'Exploit Database scanner for public exploits',
            'base_url': self.base_url,
            'version': '1.0.0',
            'supported_features': [
                'package_search',
                'exploit_detection',
                'web_scraping',
                'api_integration'
            ],
            'data_sources': ['exploit-db.com'],
            'update_frequency': 'daily'
        }